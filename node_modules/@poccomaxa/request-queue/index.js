"use strict";
module.exports = RequestQueue;
module.exports.Request = request;

const https = require("https");
const http = require("http");
const Semaphore = require("@poccomaxa/semaphore");
const merge = require("@poccomaxa/common-functions").merge;

const METHODS = {
    GET: 0,
    POST: 1,
    PUT: 2,
    DELETE: 3,
    length: 4
};
const STD = [];
STD[METHODS.GET] = {
    "method": "GET",
    "headers": {
        "Connection": "Keep-Alive"
    }
};
STD[METHODS.POST] = {
    "method": "POST",
    "headers": {
        "Content-Type": "application/x-www-form-urlencoded",
        "Connection": "Keep-Alive"
    }
};
STD[METHODS.PUT] = {
    "method": "PUT",
    "headers": {
        "Content-Type": "application/x-www-form-urlencoded",
        "Connection": "Keep-Alive"
    }
};
STD[METHODS.DELETE] = {
    "method": "DELETE",
    "headers": {
        "Connection": "Keep-Alive"
    }
};

/**
 * returns arg (responseText, statusCode, headers)
 * returns arg (Error, -1)
 *
 * @param options {object}
 * @param data {String}
 * @param callback {Function.<string, string, object>=null}
 * @param secured {boolean=false}
 */
function request(options, data, callback, secured) {
    const req = (secured ? https : http).request(options, res => {
        let arr = [];
        res.on("data", chunk => arr.push(chunk));
        res.on("end", function () {
            arr = Buffer.concat(arr);
            if (callback instanceof Function)
                process.nextTick(callback, arr.toString(), res.statusCode, res.headers, arr);
        });
    });
    req.on("error", e => process.nextTick(callback, e, -1, {}));
    req.end(data);
}

/**
 * @param defaults {object} default options and headers as options of http.ClientRequest
 * @param parallel {number=1} number of parallel requests
 * @param secured {boolean=false} true - https, false - http
 * @param keepsession {boolean=false} true - new cookies will be saved, false - cookies will be ignored
 * @constructor
 */
function RequestQueue(defaults, parallel, secured, keepsession) {
    const semaphore = new Semaphore(parallel);

    let std = new Array(METHODS.length);
    let cookies = {};

    // init
    if (defaults === undefined)
        defaults = {};
    if (defaults.headers === undefined)
        defaults.headers = {};
    parseCookies();
    updateStd();

    function updateStd() {
        for (let i = 0; i < STD.length; i++)
            std[i] = merge([defaults, STD[i]]);
    }

    function enter(method_id, options, data, callback, follow302) {
        semaphore.enter(function () {
            request(merge([std[method_id], options]), data, (response, status, headers, buffer) => {
                semaphore.leave();
                if (keepsession)
                    keepSession(headers);
                if (follow302 && status === 302 && headers.location)
                    enter(METHODS.GET, {"path": headers.location}, null, callback, true);
                else if (callback instanceof Function)
                    process.nextTick(callback, response, status, headers, buffer);
            }, secured);
        });
    }

    function parseCookies() {
        let hcookies = defaults.headers.cookie;
        if (typeof hcookies === "string") {
            hcookies = hcookies.split(";");
            let name, value;
            for (let i = 0, len = hcookies.length; i < len; i++) {
                value = hcookies[i].split("=");
                name = value.shift().trim();
                value = value.join("=").trim();
                cookies[name] = value;
            }
        }
        buildCookies();
    }

    function buildCookies() {
        let res = [];
        for (let key in cookies)
            if (cookies[key] === null)
                delete cookies[key];
            else
                res.push(key + "=" + cookies[key]);
        if (res.length)
            defaults.headers.cookie = res.join("; ");
        else
            delete defaults.headers.cookie;
        updateStd();
    }

    function keepSession(headers) {
        let setcookie = headers["set-cookie"];
        if (setcookie === undefined) return;
        let len = setcookie.length;
        let newcookies = {};
        for (let i = 0; i < len; i++) {
            let value = setcookie[i].split(";")[0];
            value = value.split("=");
            let name = value.shift().trim();
            value = value.join("=").trim();
            if (value.toLowerCase() === "deleted")
                newcookies[name] = null;
            else
                newcookies[name] = value;
        }
        cookies = merge([cookies, newcookies]);
        buildCookies();
    }

    /**
     * post-request with header "Content-Type: application/x-www-form-urlencoded"
     * @param path {String} url
     * @param data {String=} requests body
     * @param callback {Function.<string, string, object>=} called after execution of request
     * @param headers {object.<String, String>=} headers of single request
     * @param dontfollow {boolean=false} do not follow redirect (status == 302)
     * */
    this.post = function (path, data, callback, headers, dontfollow) {
        let opt = {"path": path};
        if (headers)
            opt.headers = headers;
        enter(METHODS.POST, opt, data, callback, !dontfollow);
    };

    /**
     * get-request without body
     * @param path {String} url
     * @param callback {Function.<string, string, object>=} called after execution of request
     * @param headers {object.<String, String>=} headers of single request
     * @param dontfollow {boolean=false} do not follow redirect (status == 302)
     * */
    this.get = function (path, callback, headers, dontfollow) {
        let opt = {"path": path};
        if (headers)
            opt.headers = headers;
        enter(METHODS.GET, opt, null, callback, !dontfollow);
    };

    /**
     * put-request with header "Content-Type: application/x-www-form-urlencoded"
     * @param path {String} url
     * @param data {String=} requests body
     * @param callback {Function.<string, string, object>=} called after execution of request
     * @param headers {object.<String, String>=} headers of single request
     * @param dontfollow {boolean=false} do not follow redirect (status == 302)
     * */
    this.put = function (path, data, callback, headers, dontfollow) {
        let opt = {"path": path};
        if (headers)
            opt.headers = headers;
        enter(METHODS.PUT, opt, data, callback, !dontfollow);
    };

    /**
     * delete-request without body
     * @param path {String} url
     * @param callback {Function.<string, string, object>=} called after execution of request
     * @param headers {object.<String, String>=} headers of single request
     * @param dontfollow {boolean=false} do not follow redirect (status == 302)
     * */
    this.delete = function (path, callback, headers, dontfollow) {
        let opt = {"path": path};
        if (headers)
            opt.headers = headers;
        enter(METHODS.DELETE, opt, null, callback, !dontfollow);
    };

    /**
     * adding or changing one header to defaults
     * @param name {String}
     * @param value {String}
     */
    this.setHeader = function (name, value) {
        defaults.headers[name] = value;
        updateStd();
    };

    /**
     * deleting header from defaults
     * @param name {String}
     */
    this.removeHeader = function (name) {
        if (defaults.headers[name])
            delete defaults.headers[name];
        updateStd();
    };

    /**
     * returns header if exists or undefined
     * @param name {String}
     * @returns {String|undefined}
     */
    this.getHeader = function (name) {
        return defaults.headers[name];
    };

    /**
     * adding or changing one cookie
     * @param name
     * @param value
     */
    this.setCookie = function (name, value) {
        cookies[name] = value;
        buildCookies();
    };

    /**
     * returns cookie if exists or undefined
     * @param name {String}
     * @returns {String|undefined}
     */
    this.getCookie = function (name) {
        return cookies[name];
    };

    /**
     * deleting header from defaults
     * @param name {String}
     */
    this.removeCookie = function (name) {
        if (cookies[name])
            delete cookies[name];
        buildCookies();
    };

    this.clearCookies = function () {
        cookies = {};
        delete defaults.headers.cookie;
        updateStd();
    };
}